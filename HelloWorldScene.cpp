/*
 * Cory Savit
 * Brick Break for Android
 * Cocos2dx Project in C++
 */
#include "HelloWorldScene.h"
#include "Replay.h"
#include "SimpleAudioEngine.h"

USING_NS_CC;

CCScene* HelloWorld::scene()
{
    // 'scene' is an autorelease object
    CCScene *scene = CCScene::create();
    
    // 'layer' is an autorelease object
    HelloWorld *layer = HelloWorld::create();

    // add layer as a child to scene
    scene->addChild(layer);

    // return the scene
    return scene;
}

// on "init" you need to initialize your instance
bool HelloWorld::init(){     
        if ( !CCLayerColor::initWithColor( ccc4(0,0,0,0) ) )
        {
            return false;
        }

        // Get window size
        _winSize = CCDirector::sharedDirector()->getWinSize();

        //Score variable and label
        _score = 0;
        _scoreLabel = CCLabelTTF::create("0", "Ariel", 40);
        _scoreLabel->setPosition(ccp(_winSize.width / 2, _winSize.height - 20));
        this->addChild(_scoreLabel);

        //create the ball
        _ball = GameSprite::gameSpriteWithFile("ball.png");
        _ball->setScale((_winSize.width/30)/_ball->getTextureRect().size.width);
        _ball->setPosition(ccp(_winSize.width/2, _winSize.height/2));
        this->addChild(_ball);

        //create the paddle
        _paddle = GameSprite::gameSpriteWithFile("paddle.png");
        _paddle->setScale((_winSize.width/5)/_paddle->getTextureRect().size.width);
        _paddle->setPosition(ccp(_winSize.width/2, _paddle->height()));
        this->addChild(_paddle);

        //blocks array for storing blocks sprites
        _blocks = new CCArray;
        createBlocks(3, 10);

        //touch enabled
        this->setTouchEnabled(true);

        //set initial vector and position for ball
    	_ball->setVector(ccp(1, -2));
    	_ball->setNextPosition(ccp(_winSize.width/2, _winSize.height/2));

    	//get the "ball" rolling if you will
        this->schedule(schedule_selector(HelloWorld::update));

        //sound varabile for on off
        sound = CCUserDefault::sharedUserDefault()->getBoolForKey("soundOn");
        if(sound){
        CocosDenshion::SimpleAudioEngine::sharedEngine()->playBackgroundMusic("Level1.wav", true);
        }
        return true;
}


void HelloWorld::menuCloseCallback(CCObject* pSender)
{
//some autogenerated stuff from a tutorial. I was too scared to take it out.
#if (CC_TARGET_PLATFORM == CC_PLATFORM_WINRT) || (CC_TARGET_PLATFORM == CC_PLATFORM_WP8)
	//
#else
    CCDirector::sharedDirector()->end();
#if (CC_TARGET_PLATFORM == CC_PLATFORM_IOS)
    exit(0);
#endif
#endif
}

HelloWorld::~HelloWorld() {
	//dump array
	if (_blocks) {
		_blocks->release();
		_blocks = NULL;
	}
}

void HelloWorld::ccTouchesBegan(CCSet* pTouches, CCEvent* event) {
	//touch the paddle
	CCSetIterator i;
	CCTouch* touch;
	CCPoint tap;

	for ( i = pTouches->begin(); i != pTouches->end(); i++) {
		touch = (CCTouch*) (*i);
		if (touch) {
			tap = touch->getLocation();
			if (_paddle->boundingBox().containsPoint(tap)) {
				_paddle->setTouch(touch);
			}
		}
	}
}

void HelloWorld::ccTouchesMoved(CCSet* pTouches, CCEvent* event) {
	//move the paddle
	CCSetIterator i;
	CCTouch* touch;
	CCPoint tap;

	for( i = pTouches->begin(); i != pTouches->end(); i++) {
		touch = (CCTouch*) (*i);
		if(touch) {
			tap = touch->getLocation();

			if(_paddle->getTouch() != NULL && _paddle->getTouch() == touch) {
				CCPoint nextPosition = tap;
				//too far left
				if (nextPosition.x < _paddle->getTextureRect().size.width)
					nextPosition.x = _paddle->getTextureRect().size.width;
				//too far right
				if (nextPosition.x > _winSize.width - _paddle->getTextureRect().size.width)
					nextPosition.x = _winSize.width - _paddle->getTextureRect().size.width;
				//don't go up. overkill
				nextPosition.y = _paddle->getTextureRect().size.height;

				_paddle->setNextPosition(nextPosition);
				_paddle->setVector(ccp(tap.x - _paddle->getPositionX(), tap.y - _paddle->getPositionY()));
			}
		}
	}
}

void HelloWorld::ccTouchesEnded(CCSet* pTouches, CCEvent* event) {
	//no more touching, stop moving.
	CCSetIterator i;
	CCTouch* touch;
	CCPoint tap;

	for( i = pTouches->begin(); i != pTouches->end(); i++) {
		touch = (CCTouch*) (*i);
		if(touch) {
			if(_paddle->getTouch() != NULL && _paddle->getTouch()== touch) {
				_paddle->setTouch(NULL);
				_paddle->setVector(ccp(0,0));
			}
		}
	}
}

void HelloWorld::update(float dt) {
	//main
	CCPoint ballNextPosition = _ball->getNextPosition();
	CCPoint ballVector = _ball->getVector();
	CCPoint paddleNextPosition;
	CCPoint paddleVector;
	CCObject* checkBlock = NULL;

	//give ball a direction
	ballNextPosition.x += ballVector.x;
	ballNextPosition.y += ballVector.y;

	//useful paddle info
	paddleNextPosition = _paddle->getNextPosition();
	paddleVector = _paddle->getVector();
	float paddleRight = _paddle->getPositionX()+(_paddle->width()/2);
	float paddleLeft = _paddle->getPositionX()-(_paddle->width()/2);
	float paddleHeight = _paddle->height();

	//useful ball info
	float balltest = ballNextPosition.y-(_ball->radius());
	float ballLeft = ballNextPosition.x-(_ball->radius());
	float ballRight = ballNextPosition.x+(_ball->radius());

	//creats a ball "rectangle" to use for collision detection
	CCRect ballRect = CCRectMake(ballNextPosition.x-(_ball->radius()),
								 ballNextPosition.y-(_ball->radius()),
								 _ball->width(),
								 _ball->height());

	//creates a paddle "rectangle
	CCRect paddleRect = CCRectMake(paddleLeft, paddleRight, _paddle->width(), _paddle->height());
	//did the ball hit the paddle?
	if(ballRect.intersectsRect(paddleRect)){
		ballVector.y *= -1;
	}




	/*if((balltest < paddleHeight && ballLeft > paddleLeft && ballRight < paddleRight)){
		ballVector.y *= -1;
		if(sound){
			CocosDenshion::SimpleAudioEngine::sharedEngine()->playEffect("beep1.wav");
		}
	}*/




	//loop through all bricks to determine if collision
	CCARRAY_FOREACH(_blocks, checkBlock){
		GameSprite* temp = dynamic_cast<GameSprite*>(checkBlock);
		//creates a rectangle for block
		CCRect blockRect = CCRectMake(temp->getPositionX()-(temp->width()/2),
									  temp->getPositionY()-(temp->height()/2),
									  temp->width(),
									  temp->height());

		//did it hit!?!?
		if(ballRect.intersectsRect(blockRect)){
				ballVector.y *= -1;
				_blocks->removeObject(temp);
				this->removeChild(temp, true);
				char scoreBuf[10];
				_score = _score+1;
				sprintf(scoreBuf, "%i", _score);
				_scoreLabel->setString(scoreBuf);
				if(sound){
					CocosDenshion::SimpleAudioEngine::sharedEngine()->playEffect("beep2.wav");
				}
		}

	}

	//boring wall hit stuff
	if (ballNextPosition.x < _ball->radius()) {
		ballNextPosition.x = _ball->radius();
		ballVector.x *= -1;
		if(sound){
			CocosDenshion::SimpleAudioEngine::sharedEngine()->playEffect("beep1.wav");
		}
	}

	if (ballNextPosition.x > _winSize.width - _ball->radius()) {
		ballNextPosition.x = _winSize.width - _ball->radius();
		ballVector.x *= -1;
		if(sound){
			CocosDenshion::SimpleAudioEngine::sharedEngine()->playEffect("beep1.wav");
		}
	}

	if (ballNextPosition.y > _winSize.height - _ball->radius()) {
		ballNextPosition.y = _winSize.height - _ball->radius();
		ballVector.y *= -1;
		if(sound){
			CocosDenshion::SimpleAudioEngine::sharedEngine()->playEffect("beep1.wav");
		}
	}

	//ball lost
	if (ballNextPosition.y  < -_ball->radius() * 2) {
		CCDirector::sharedDirector()->replaceScene(Replay::scene());
	}

	_ball->setVector(ballVector);
	_ball->setNextPosition(ballNextPosition);
	_ball->setPosition(_ball->getNextPosition());
	_paddle->setPosition(_paddle->getNextPosition());

	if(_blocks->count()==0){
		CCDirector::sharedDirector()->replaceScene(Replay::scene());
	}


}

void HelloWorld::createBlocks(int rows, int cols) {

	float blockWidth = _winSize.width/cols;
	float blockHeight = _winSize.height/20;
	float blockHorCenter = blockWidth / 2;
	float blockVertCenter = _winSize.height - _winSize.height / 5;

	//creates and lays out blocks.
	//puts them in an array for access during collisions
	for (int rownum = 0;rownum < rows;rownum++) {
		for (int colnum = 0;colnum < cols;colnum++) {
			float xPos = (colnum * blockWidth) + blockHorCenter;
			float yPos = blockVertCenter - (rownum * blockHeight);
			GameSprite * block = GameSprite::gameSpriteWithFile("block.png");

			block->setPosition(ccp(xPos, yPos));
			block->setScaleX(blockWidth / block->getTextureRect().size.width);
			block->setScaleY(blockHeight / block->getTextureRect().size.height);

			_blocks->addObject(block);
			this->addChild(block);
		}
	}
}
